# 组成

1. ECMAScript（JavaScript语法）
2. DOM（文档对象模型）
3. BOM（浏览器对象模型）

# 使用Javascript

1. 行内式的Js

```javascript
<input type="button" value="唐伯虎" onclick="alert('秋香')">
```

2. 内嵌式的Js

```javascript
    <script>
        alert('hello world')
    </script>
```

3. 外联式的Js

```javascript
<script src="Day1.js"></script>
```

外联式的Js,标签中间不能写代码

# Javascript的注释

单行注释：ctrl+/

多行注释：shift+alt+a

# Javascript输入输出语句

### 输入

prompt(info)

浏览器中弹出输入框，用户可以输入

### 输出

alert(info)

弹出警示框，显示info的内容

console.log(info)

在控制台中输出，我们要查看就要到检查的console页面看

# 变量

### 声明变量

```javascript
var age;//声明一个名为age的变量
var age = 18; //可以理解为变量的初始化
```

var = variable(可变的)

变量连续赋值：

```javascript
var myname = '空条承太郎',
    age = 18,
    payment = 0;
```

每次必须是,结尾

### 声明变量的特殊情况

```javascript
var sex;
console.log(sex);
```

未初始化的变量被输出的结果就是undefined

```javascript
console.log(drink);
```

要用没有定义的变量会直接报错

```javascript
age = 10;
console.log(age)
```

变量未声明直接使用也是可以的，会变成全局变量

### 变量命名

区分大小写

由大小写字母、数字、下划线和美元符号构成

不能以数字开头

# 数据类型

var num,变量的数据类型在一开始声明的时候是不知道的

要赋值之后才知道，而且可以变，类似于Python

在赋值过程中0开头的数字为八进制，0x开头为十六进制，在输出的时候默认为十进制输出

数值的最大值和最小值也是可以直接调用的

```javascript
console.log(Number.MAX_VALUE);
console.log(Number.MIN_VALUE);
```

Number.MAX_VALUE*2 = Infinity

字符串类型在表达的时候注意引号的嵌套

外单内双或者外双内单

转义字符参考其他的语言

### 字符串

```javascript
var myname = 'myname';
console.log(myname.length);
```

length属性为字符串的长度

字符串的拼接和Python的做法一样

```javascript
var str = 'hello '+'world';
var str = 'David'+18;//这里18会自主转换成字符串的类型
var str = 'David'+true//这里true自动转为字符串
```

在javascript里面不能使用字符串格式化，只能通过字符串拼接来实现

### boolean型

boolean型变量在计算中相当于1和0，在数值运算中可以这么等价地看

### undefined

undefined是单独的一类数据类型

```javascript
var str;
console.log(str)//此时的输出就是undefined
console.log(str+1)//此时的输出为NaN
```

由于不清楚undefined到底是什么数据类型，所以会输出NaN

### null空值

```javascript
var space = null;
console.log(space+'David');//输出为nullDavid
console.log(space+1);//输出为1
```

### 获取数据类型

```javascript
var num = 10;
console.log(typeof num);
```

### 字面量

就是我们看到的样子

### 数据类型转换

1. 转换为字符串

| 方式       | 案例                                         |
| ---------- | -------------------------------------------- |
| toString() | var num = 1; console.log(num.toString(num)); |
| String()   | var num = 1; console.log(String(num));       |
| 加号拼接   | var num = 1; console.log(num+'这是字符串')； |

2. 转换为数字型

| 方式               | 提示                             | 案例                                            |
| ------------------ | -------------------------------- | ----------------------------------------------- |
| parseInt(string)   | 这个是取整的，把小数位直接截取了 | var num = '18'; console.log(parseInt(num));     |
| parseFloat(string) | 可以帮你保留整数                 | var num = '11.5'; console.log(parseFloat(num)); |
| Number(string)     | 将string类型转换为数值型         | Number('12');                                   |
| 隐式转换（- * /）  | 利用算术运算转换                 | '12'-0;                                         |

parseInt如果参数为带有单位的字符串，就会把单位给去除

3. 转换为布尔型

只有一种方法，就是Boolean('true');

代表空、否定的值都会被转换成false；

# 运算符

### 算术运算符

参考C语言

### 比较运算符

参考C语言

有一个不同点：

===全等，即数值，数据类型都相同

!==不全等

而且在==中存在默认转换数据类型的功能，所以'18'==18的返回值也是true

### 逻辑运算符

参考C语言

# 流程控制

## if 结构

语法结构和C语言几乎一样

```javascript
if ()
    {
        
    }
else if ()
    {
        
    }
else if ()
    {
        
    }
else 
    {
        
    }
```

### 三元表达式

``` javascript
条件表达式 ? 表达式1 : 表达式2;
```

true的话返回值为表达式1，否则返回表达式2

### switch

``` javascript
switch (语句) {
    case 表达式1:
        语句...
    case 表达式2:
        语句...
    default:
        语句...
}
```

```javascript
var month = 10;
switch (month) {
    case 1:
    case 3:
    case 5:
    case 7:
    case 8:
    case 10:
    case 12:
        console.log("31天");
        break;
    case 4:
    case 6:
    case 9:
    case 11:
        console.log("30天");
        break;
    case 2:
        console.log("28天");
        break;
    default:
        console.log("输入错误");
}
```

用法和C语言一样

## 循环结构

基本和C语言一致

### 特殊地方

特殊的地方在跳转控制上

```javascript
outer: for (var i = 0; i < 10; i++) {
    for (var j = 0; j < 10; j++) {
        if (j == 5) {
            break outer;//直接跳出outer标记的循环
        }
        console.log(j);
    }
}
```

通过对某一次循环进行标记，来实现下一次直接跳出被标记的循环的功能。

# 对象

### 创建方式

1. 先声明再赋值

   ``` javascript
   var person = new Object();
   person.name = 'David';
   person.weight = 53;
   ```

   ![输出结果](https://s3.bmp.ovh/imgs/2022/07/04/4fb3e450d76d3e79.png)

​		输出结果就是这样



2. 直接初始化

   ```javascript
   var person = {
       name:'David',
       weight:53
   };
   console.log(person);
   ```

   写法和Python的字典一样

### 访问属性

1. C语言风格

   ```javascript
   person.name;
   ```

2. Python风格

   ```javascript
   person['name']
   ```

### 删除属性

```javascript
delete person.weight
```

### 遍历对象

使用for in来遍历

```javascript
var person =
    {
        name:'David',
        weight:53,
        height:172
    }
for (var personAttr in person )
    {
        var personValue = person[personAttr];
        console.log(personAttr+':'+personValue+'\n');
    }
```

这里的for in 语句和Python中的for循环用法相近，就是别忘了括号

### 深入认识本质

当一个变量是一个对象时，实际上变量中保存的并不是对象本身，而是对象的引用。

当从一个变量向另一个变量复制引用类型的值时，会将对象的引用复制到变量中，并不是创建一个新的对象。

这时，两个变量指向的是同一个对象。因此，改变其中一个变量会影响另一个。

```javascript
var person =
    {
        name:'David',
        weight:53,
        height:172
    };
for (var personAttr in person )
    {
        var personValue = person[personAttr];
        console.log(personAttr+':'+personValue+'\n');
    }
person2 = person;
person2.name = 'Zed';
for (var personAttr in person )
    {
        var personValue = person[personAttr];
        console.log(personAttr+':'+personValue+'\n');
    }
//以下为输出
name:David
weight:53
height:172
name:Zed
weight:53
height:172
```

# 函数

### 声明函数

1. 函数声明方式：

   ```javascript
   function fun()
   {
       console.log('hello world!');
   }
   ```

2. 函数表达式：

   ```javascript
   var fun = function()
   {
       console,log('hello world!');
   }
   ```

   这样其实是写了一个匿名函数，让一个变量来接收函数的逻辑关系

3. 对象中的函数

   ```javascript
   var person = {
       name: "zhangsan",
       age: 18,
       sayHello: function () {
           console.log(name + " hello")
       }
   }
   person.sayHello();
   ```

   相当于匿名函数

4. 立即执行函数

   ```javascript
   (function () {
       alert("我是一个匿名函数");
   })();
   ```

### this对象

类似于指针，在调用函数的时候，都会传入this

根据函数的调用方式的不同，this会指向不同的对象

- 以函数的形式调用时，this永远都是全局
- 以对象的一个方法的形式调用时，this就是调用方法的那个对象

```javascript
//创建一个全局变量name
var name = "全局变量name";
//创建一个函数
function fun() {
    console.log(this.name);
}
//创建一个对象
var obj = {
    name: "孙悟空",
    sayName: fun
};
//我们希望调用obj.sayName()时可以输出obj的名字而不是全局变量name的名字
obj.sayName();
```

# 对象进阶

### 工厂方式创建对象

```javascript
function createperson(name,age)
{
    var obj = snew Object();
    obj.name = name;
    obj.age = age;
    obj.printperson = function()
    {
        console.log(this.name+'\n');
    }
    return obj;
}

person1 = createperson('David',20);
person2 = createperson('Zed',20);
person3 = createperson('PJ',20);

person1.printperson();
person2.printperson();
person3.printperson();
```

一般的单独创建的方式过于繁琐，可以用这个来创建

### 构造函数创建对象

```javascript
function Person(name,age)
{
    this.name = name;
    this.age = age;
    this.printperson = function()
    {
        console.log(this.name+'\n');
    }
}

person1 = new Person('David',20);
person2 = new Person('Zed',20);
person3 = new Person('PJ',20);

console.log(person1);
console.log(person2);
console.log(person3);
```

可以理解为创建了一个类Person，然后Person是这个类的构造函数

构造函数习惯上首字母大写

普通函数是直接调用，而构造函数需要使用new关键字来调用

##### 小技巧

判断一个对象是否为某一个类的实例化对象

可以使用函数instanceof

```javascript
console.log(person1 instanceof Person);
```

### 原型

原先的代码：

```javascript
function Person(name,age)
{
    this.name = name;
    this.age = age;
    this.printperson = function()
    {
        console.log(this.name+'\n');
    }
}
```

每次创建时会造成内存空间的浪费

有没有可以只占用一个空间但是可以被所有对象引用的方式呢？

就是原型

```javascript
function Person(name, age) {
    // 设置对象的属性
    this.name = name;
    this.age = age;
}

// 在Person类的原型对象中添加方法
Person.prototype.sayName = function() {
    console.log(this.name);
};

var person1 = new Person("孙悟空", 18);
var person2 = new Person("猪八戒", 19);
var person3 = new Person("沙和尚", 20);

person1.sayName();
person2.sayName();
person3.sayName();

```

原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。

### toString方法

toString方法是对象的方法之一，能够将对象以字符串的形式返回

但是对象进行toString之后只返回[object Object]

### 对象继承

##### 原型链继承

```javascript
// 定义父类型构造函数
function SupperType() {
    this.supProp = 'Supper property';
}

// 给父类型的原型添加方法
SupperType.prototype.showSupperProp = function () {
    console.log(this.supProp);
};

// 定义子类型的构造函数
function SubType() {
    this.subProp = 'Sub property';
}

// 创建父类型的对象赋值给子类型的原型
SubType.prototype = new SupperType();

// 将子类型原型的构造属性设置为子类型
SubType.prototype.constructor = SubType;

// 给子类型原型添加方法
SubType.prototype.showSubProp = function () {
    console.log(this.subProp)
};

// 创建子类型的对象: 可以调用父类型的方法
var subType = new SubType();
subType.showSupperProp();
subType.showSubProp();
```

这种方式不能传参

##### 借用构造函数继承

```javascript
// 定义父类型构造函数
function SuperType(name) {
    this.name = name;
    this.showSupperName = function () {
        console.log(this.name);
    };
}

// 定义子类型的构造函数
function SubType(name, age) {
    // 在子类型中调用call方法继承自SuperType
    SuperType.call(this, name);
    this.age = age;
}

// 给子类型的原型添加方法
SubType.prototype.showSubName = function () {
    console.log(this.name);
};

// 创建子类型的对象然后调用
var subType = new SubType("孙悟空", 20);
subType.showSupperName();
subType.showSubName();
console.log(subType.name);
console.log(subType.age);
```

这种方式会导致代码比较臃肿

##### 组合继承（Js中最常用）

```javascript
function Person(name,age)
{
    this.name = name;
    this.age = age;
}

Person.prototype.Setgender = function(gender)
{
    this.gender = gender;
}

function Student(name,age,score)
{
    Person.call(this,name,age);
    this.score = score;
}

Student.prototype = new Person();
Student.prototype.constructor = Student;
Student.prototype.setScore = function(score)
{
    this.score = score;
}

var s = new Student('David',20,89.0);
console.log(s);
s.Setgender('M');
s.setScore(100);
console.log(s);
```

在写的时候千万不要忘记call函数里面的this指针

### 垃圾回收

在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作，我们需要做的只是要将不再使用的对象设置null即可。

```javascript
function Person(name,age)
{
    this.name = name;
    this.age = age;
}

Person.prototype.Setgender = function(gender)
{
    this.gender = gender;
}

function Student(name,age,score)
{
    Person.call(this,name,age);
    this.score = score;
}

Student.prototype = new Person();
Student.prototype.constructor = Student;
Student.prototype.setScore = function(score)
{
    this.score = score;
}

var s = new Student('David',20,89.0);
console.log(s);
s.Setgender('M');
s.setScore(100);
console.log(s);

s = null;
```

最后对象s被赋上了null后，就可以被自动回收。

# Js常用对象

### 数组对象

使用typeof检查一个数组对象时，会返回object

##### 数组的创建

```javascript
var arr = new Arry();
arr[0] = 1;
arr[1] = 2;
```

但是其实数组的元素也可以是不同类型的元素

```javascript
var arr = new Arry();
arr[0] = 1;
arr[1] = '2';
```

也可以使用Python风格的创建方式

```javascript
var arr = [1,2,'3'];
```

##### 数组的方法

- push方法

  向数组末尾添加元素

  ```javascript
  var arr = [1,2,3];
  var result = arr.push(4,5,6);
  console.log(arr);
  console.log(result);
  ```

  arr.push(...)返回值是添加元素之后的数组长度

- pop方法

  删除数组的最后一个元素

  ```javascript
  var arr = [1,2,3];
  var result = arr.pop();
  console.log(arr);
  console.log(result);
  coonsole.log(typeof result);
  ```

  返回值是被删除的元素

- unshift方法

  向数组开头增加元素，并且返回增加之后的数组长度

- shift方法

  删除数组开头的元素，并且返回被删除的元素

- forEach()方法

  参数为回调函数，不由我们调用。

  forEach()有三个参数，第一个参数就是当前正在遍历的元素；第二个参数就是当前正在遍历的元素的索引；第三个参数就是正在遍历的数组。

  ```javascript
  var arr = [1,2,3];
  arr.forEach(function(value,index,obj){
      console.log(value+'###'+index+'###'+obj);
  });
  ```

  浏览器会自主调用forEach()中定义的回调函数

- slice()方法

  数组的切片

  有两个参数，第一个是起始索引处，第二个是终点索引处，终点不包含。

  返回值是单独被切开来的数组，原来的数组不会受影响。

- splice()方法

  前面有pop()和shift()方法，但是这两种方法无法针对中间位置的元素的删除需求，所以还需要有新的方法

  该方法7有三个参数，第一个参数表示开始位置的索引，第二个参数表示要删除的元素数量，第三个参数及以后参数可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边。

  ```javascript
  var arr = [1,2,3,4,5,6,7,8];
  var returnValue = arr.splice(0,2,'David','Zed');
  console.log(arr);
  console.log(returnValue);
  ```

- concat()方法

  可以连接两个或多个数组，并将新的数组返回，该方法不会对原数组产生影响

- join()方法

  可以将数组转换为一个字符串，该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回，在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符，如果不指定连接符，则默认使用，作为连接符。

- sort方法（需要重点注意的地方）

  默认进行Unicode编码

  ```javascript
  var arr = ["b", "c", "a"];
  arr.sort();
  console.log(arr);
  ```

  所以在字符排序中能够i正常排序，但是遇到数字的时候就会出问题

  所以在对数字进行排序的时候我们需要自己写好回调函数

  sort方法中，回调函数中有两个参数，能够确定的只有第一个参数在数组中的位置在第二个参数的右边

  ```javascript
  var arr = [2,6,1,3,11,7];
  arr.sort(fuction(a,b){
           return a-b;
           }); //a-b>0时会左右调换
  ```

### 函数对象

##### call()方法

调用call()函数时，可以将一个对象指定为第一个参数。

这个第一个对象会成为函数里面的this

```javascript
function fun(a, b) {
    console.log("a = " + a);
    console.log("b = " + b);
    console.log("fun = " + this);
}

var obj = {
    name: "obj",
    sayName: function () {
        console.log(this.name);
    }
};

fun(2, 3);
console.log("===============");
fun.call(obj, 2, 3);
```

默认fun()函数调用，this指向的是window对象，你可以使用call()调用函数，在调用的时候传入一个对象，这个对象就是this所指向的对象，也就是说，可以自己指定this的指向，然后从第二个参数开始，实参将会依次传递.

##### apply()方法

基本和call()方法是一个用法，但是在参数上面call()第二个参数的位置的参数用数组包装起来了

```javascript
function fun(a, b) {
    console.log("a = " + a);
    console.log("b = " + b);
    console.log("fun = " + this);
}

var obj = {
    name: "obj",
    sayName: function () {
        console.log(this.name);
    }
};

fun(2, 3);
console.log("===============");
fun.apply(obj, [2, 3]);
```

##### arguments参数

封装实参的对象

在调用函数时，我们所传递的实参都会在arguments中保存

arguments[0]表示第一个实参，以此类推

arguments有一个属性叫做callee，这个属性对应一个函数对象，就是当前正在指向的函数的对象

```javascript
function fun(a,b)
{
    //打印两个参数
    console.log(arguments[0]);
    console.log(arguments[1]);
    //打印参数的个数
    console.log(arguments.length);
    //打印调用这些参数的函数
    console.log(arguments.callee);
    console.log(arguments.callee==fun);
}

fun("a","b");
```

#### Date对象

```javascript
var date = new Date();
console.log(date);

console.log(date.getFullYear());//获取当前日期对象的年份(四位数字年份)
console.log(date.getMonth());//获取当前日期对象的月份(0 ~ 11)
console.log(date.getDate());//获取当前日期对象的日数(1 ~ 31)
console.log(date.getHours());//获取当前日期对象的小时(0 ~ 23)
console.log(date.getMinutes());//获取当前日期对象的分钟(0 ~ 59)
console.log(date.getSeconds());//获取当前日期对象的秒钟(0 ~ 59)
console.log(date.getMilliseconds());//获取当前日期对象的毫秒(0 ~ 999)
```

### String对象

##### 字符串方法

- charAt()方法：

  ```javascript
  var str = "hello world.";
  console.log(str.charAt(1));
  ```

  能够获取参数值对应索引值的字符

- charCodeAt()方法：

  ```javascript
  var str = "abd";
  console.log(str.charCodeAt(0));
  ```

  能够获取参数值对应索引字符的Unicode编码

- indexOf()方法：

  ```javascript
  var str = "hello hello";
  console.log(str.indexOf("e"));
  ```

  能够返回第一次出现指定字符的位置的索引值

- lastIndexOf()方法:

  ```javascript
  var str = "hello hello";
  console.log(str.lastIndexOf("e"));
  ```

  能够返回最后一次出现指定字符的位置的索引值

- slice()方法：

  ```javascript
  var str = "abcdefghijk";
  console.log(str.slice(1,3));
  ```

  也就是切片，对原字符串不造成影响

- split()方法

  ```javascript
  var str = "hello,world.";
  console.log(str.split(","));
  ```

  分割，以参数里面的字符为界，分割后的结果存在一个数组里面

- toUpperCase(),toLowerCase()方法：

  ```javascript
  var str = "hello,world";
  var STR = str.toUpperCase();
  var str = STR.toLowerCase();
  console.log(str);
  console.log(STR);
  ```

  toUpperCase()将小写的字符全部转化为大写，toLowerCase()方法将所有字符都转为小写。
