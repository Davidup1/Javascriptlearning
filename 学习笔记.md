# 组成

1. ECMAScript（JavaScript语法）
2. DOM（文档对象模型）
3. BOM（浏览器对象模型）

# 使用Javascript

1. 行内式的Js

```javascript
<input type="button" value="唐伯虎" onclick="alert('秋香')">
```

2. 内嵌式的Js

```javascript
    <script>
        alert('hello world')
    </script>
```

3. 外联式的Js

```javascript
<script src="Day1.js"></script>
```

外联式的Js,标签中间不能写代码

# Javascript的注释

单行注释：ctrl+/

多行注释：shift+alt+a

# Javascript输入输出语句

### 输入

prompt(info)

浏览器中弹出输入框，用户可以输入

### 输出

alert(info)

弹出警示框，显示info的内容

console.log(info)

在控制台中输出，我们要查看就要到检查的console页面看

# 变量

### 声明变量

```javascript
var age;//声明一个名为age的变量
var age = 18; //可以理解为变量的初始化
```

var = variable(可变的)

变量连续赋值：

```javascript
var myname = '空条承太郎',
    age = 18,
    payment = 0;
```

每次必须是,结尾

### 声明变量的特殊情况

```javascript
var sex;
console.log(sex);
```

未初始化的变量被输出的结果就是undefined

```javascript
console.log(drink);
```

要用没有定义的变量会直接报错

```javascript
age = 10;
console.log(age)
```

变量未声明直接使用也是可以的，会变成全局变量

### 变量命名

区分大小写

由大小写字母、数字、下划线和美元符号构成

不能以数字开头

# 数据类型

var num,变量的数据类型在一开始声明的时候是不知道的

要赋值之后才知道，而且可以变，类似于Python

在赋值过程中0开头的数字为八进制，0x开头为十六进制，在输出的时候默认为十进制输出

数值的最大值和最小值也是可以直接调用的

```javascript
console.log(Number.MAX_VALUE);
console.log(Number.MIN_VALUE);
```

Number.MAX_VALUE*2 = Infinity

字符串类型在表达的时候注意引号的嵌套

外单内双或者外双内单

转义字符参考其他的语言

### 字符串

```javascript
var myname = 'myname';
console.log(myname.length);
```

length属性为字符串的长度

字符串的拼接和Python的做法一样

```javascript
var str = 'hello '+'world';
var str = 'David'+18;//这里18会自主转换成字符串的类型
var str = 'David'+true//这里true自动转为字符串
```

在javascript里面不能使用字符串格式化，只能通过字符串拼接来实现

### boolean型

boolean型变量在计算中相当于1和0，在数值运算中可以这么等价地看

### undefined

undefined是单独的一类数据类型

```javascript
var str;
console.log(str)//此时的输出就是undefined
console.log(str+1)//此时的输出为NaN
```

由于不清楚undefined到底是什么数据类型，所以会输出NaN

### null空值

```javascript
var space = null;
console.log(space+'David');//输出为nullDavid
console.log(space+1);//输出为1
```

### 获取数据类型

```javascript
var num = 10;
console.log(typeof num);
```

### 字面量

就是我们看到的样子

### 数据类型转换

1. 转换为字符串

| 方式       | 案例                                         |
| ---------- | -------------------------------------------- |
| toString() | var num = 1; console.log(num.toString(num)); |
| String()   | var num = 1; console.log(String(num));       |
| 加号拼接   | var num = 1; console.log(num+'这是字符串')； |

2. 转换为数字型

| 方式               | 提示                             | 案例                                            |
| ------------------ | -------------------------------- | ----------------------------------------------- |
| parseInt(string)   | 这个是取整的，把小数位直接截取了 | var num = '18'; console.log(parseInt(num));     |
| parseFloat(string) | 可以帮你保留整数                 | var num = '11.5'; console.log(parseFloat(num)); |
| Number(string)     | 将string类型转换为数值型         | Number('12');                                   |
| 隐式转换（- * /）  | 利用算术运算转换                 | '12'-0;                                         |

parseInt如果参数为带有单位的字符串，就会把单位给去除

3. 转换为布尔型

只有一种方法，就是Boolean('true');

代表空、否定的值都会被转换成false；

# 运算符

### 算术运算符

参考C语言

### 比较运算符

参考C语言

有一个不同点：

===全等，即数值，数据类型都相同

!==不全等

而且在==中存在默认转换数据类型的功能，所以'18'==18的返回值也是true

### 逻辑运算符

参考C语言

# 流程控制

## if 结构

语法结构和C语言几乎一样

```javascript
if ()
    {
        
    }
else if ()
    {
        
    }
else if ()
    {
        
    }
else 
    {
        
    }
```

### 三元表达式

``` javascript
条件表达式 ? 表达式1 : 表达式2;
```

true的话返回值为表达式1，否则返回表达式2

### switch

``` javascript
switch (语句) {
    case 表达式1:
        语句...
    case 表达式2:
        语句...
    default:
        语句...
}
```

```javascript
var month = 10;
switch (month) {
    case 1:
    case 3:
    case 5:
    case 7:
    case 8:
    case 10:
    case 12:
        console.log("31天");
        break;
    case 4:
    case 6:
    case 9:
    case 11:
        console.log("30天");
        break;
    case 2:
        console.log("28天");
        break;
    default:
        console.log("输入错误");
}
```

用法和C语言一样

## 循环结构

基本和C语言一致

### 特殊地方

特殊的地方在跳转控制上

```javascript
outer: for (var i = 0; i < 10; i++) {
    for (var j = 0; j < 10; j++) {
        if (j == 5) {
            break outer;//直接跳出outer标记的循环
        }
        console.log(j);
    }
}
```

通过对某一次循环进行标记，来实现下一次直接跳出被标记的循环的功能。

# 对象

### 创建方式

1. 先声明再赋值

   ``` javascript
   var person = new Object();
   person.name = 'David';
   person.weight = 53;
   ```

   ![输出结果](https://s3.bmp.ovh/imgs/2022/07/04/4fb3e450d76d3e79.png)

​		输出结果就是这样



2. 直接初始化

   ```javascript
   var person = {
       name:'David',
       weight:53
   };
   console.log(person);
   ```

   写法和Python的字典一样

### 访问属性

1. C语言风格

   ```javascript
   person.name;
   ```

2. Python风格

   ```javascript
   person['name']
   ```

### 删除属性

```javascript
delete person.weight
```

### 遍历对象

使用for in来遍历

```javascript
var person =
    {
        name:'David',
        weight:53,
        height:172
    }
for (var personAttr in person )
    {
        var personValue = person[personAttr];
        console.log(personAttr+':'+personValue+'\n');
    }
```

这里的for in 语句和Python中的for循环用法相近，就是别忘了括号

### 深入认识本质

当一个变量是一个对象时，实际上变量中保存的并不是对象本身，而是对象的引用。

当从一个变量向另一个变量复制引用类型的值时，会将对象的引用复制到变量中，并不是创建一个新的对象。

这时，两个变量指向的是同一个对象。因此，改变其中一个变量会影响另一个。

```javascript
var person =
    {
        name:'David',
        weight:53,
        height:172
    };
for (var personAttr in person )
    {
        var personValue = person[personAttr];
        console.log(personAttr+':'+personValue+'\n');
    }
person2 = person;
person2.name = 'Zed';
for (var personAttr in person )
    {
        var personValue = person[personAttr];
        console.log(personAttr+':'+personValue+'\n');
    }
//以下为输出
name:David
weight:53
height:172
name:Zed
weight:53
height:172
```

# 函数

### 声明函数

1. 函数声明方式：

   ```javascript
   function fun()
   {
       console.log('hello world!');
   }
   ```

2. 函数表达式：

   ```javascript
   var fun = function()
   {
       console,log('hello world!');
   }
   ```

   这样其实是写了一个匿名函数，让一个变量来接收函数的逻辑关系

3. 对象中的函数

   ```javascript
   var person = {
       name: "zhangsan",
       age: 18,
       sayHello: function () {
           console.log(name + " hello")
       }
   }
   person.sayHello();
   ```

   相当于匿名函数

4. 立即执行函数

   ```javascript
   (function () {
       alert("我是一个匿名函数");
   })();
   ```

### this对象

类似于指针，在调用函数的时候，都会传入this

根据函数的调用方式的不同，this会指向不同的对象

- 以函数的形式调用时，this永远都是全局
- 以对象的一个方法的形式调用时，this就是调用方法的那个对象

```javascript
//创建一个全局变量name
var name = "全局变量name";
//创建一个函数
function fun() {
    console.log(this.name);
}
//创建一个对象
var obj = {
    name: "孙悟空",
    sayName: fun
};
//我们希望调用obj.sayName()时可以输出obj的名字而不是全局变量name的名字
obj.sayName();
```

# 对象进阶

### 工厂方式创建对象

```javascript
function createperson(name,age)
{
    var obj = snew Object();
    obj.name = name;
    obj.age = age;
    obj.printperson = function()
    {
        console.log(this.name+'\n');
    }
    return obj;
}

person1 = createperson('David',20);
person2 = createperson('Zed',20);
person3 = createperson('PJ',20);

person1.printperson();
person2.printperson();
person3.printperson();
```

一般的单独创建的方式过于繁琐，可以用这个来创建

### 构造函数创建对象

```javascript
function Person(name,age)
{
    this.name = name;
    this.age = age;
    this.printperson = function()
    {
        console.log(this.name+'\n');
    }
}

person1 = new Person('David',20);
person2 = new Person('Zed',20);
person3 = new Person('PJ',20);

console.log(person1);
console.log(person2);
console.log(person3);
```

可以理解为创建了一个类Person，然后Person是这个类的构造函数

构造函数习惯上首字母大写

普通函数是直接调用，而构造函数需要使用new关键字来调用

##### 小技巧

判断一个对象是否为某一个类的实例化对象

可以使用函数instanceof

```javascript
console.log(person1 instanceof Person);
```

### 原型

原先的代码：

```javascript
function Person(name,age)
{
    this.name = name;
    this.age = age;
    this.printperson = function()
    {
        console.log(this.name+'\n');
    }
}
```

每次创建时会造成内存空间的浪费

有没有可以只占用一个空间但是可以被所有对象引用的方式呢？

就是原型

```javascript
function Person(name, age) {
    // 设置对象的属性
    this.name = name;
    this.age = age;
}

// 在Person类的原型对象中添加方法
Person.prototype.sayName = function() {
    console.log(this.name);
};

var person1 = new Person("孙悟空", 18);
var person2 = new Person("猪八戒", 19);
var person3 = new Person("沙和尚", 20);

person1.sayName();
person2.sayName();
person3.sayName();

```

原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。

### toString方法

toString方法是对象的方法之一，能够将对象以字符串的形式返回

但是对象进行toString之后只返回[object Object]

### 对象继承

##### 原型链继承

```javascript
// 定义父类型构造函数
function SupperType() {
    this.supProp = 'Supper property';
}

// 给父类型的原型添加方法
SupperType.prototype.showSupperProp = function () {
    console.log(this.supProp);
};

// 定义子类型的构造函数
function SubType() {
    this.subProp = 'Sub property';
}

// 创建父类型的对象赋值给子类型的原型
SubType.prototype = new SupperType();

// 将子类型原型的构造属性设置为子类型
SubType.prototype.constructor = SubType;

// 给子类型原型添加方法
SubType.prototype.showSubProp = function () {
    console.log(this.subProp)
};

// 创建子类型的对象: 可以调用父类型的方法
var subType = new SubType();
subType.showSupperProp();
subType.showSubProp();
```

这种方式不能传参

##### 借用构造函数继承

```javascript
// 定义父类型构造函数
function SuperType(name) {
    this.name = name;
    this.showSupperName = function () {
        console.log(this.name);
    };
}

// 定义子类型的构造函数
function SubType(name, age) {
    // 在子类型中调用call方法继承自SuperType
    SuperType.call(this, name);
    this.age = age;
}

// 给子类型的原型添加方法
SubType.prototype.showSubName = function () {
    console.log(this.name);
};

// 创建子类型的对象然后调用
var subType = new SubType("孙悟空", 20);
subType.showSupperName();
subType.showSubName();
console.log(subType.name);
console.log(subType.age);
```

这种方式会导致代码比较臃肿

##### 组合继承（Js中最常用）

```javascript
function Person(name,age)
{
    this.name = name;
    this.age = age;
}

Person.prototype.Setgender = function(gender)
{
    this.gender = gender;
}

function Student(name,age,score)
{
    Person.call(this,name,age);
    this.score = score;
}

Student.prototype = new Person();
Student.prototype.constructor = Student;
Student.prototype.setScore = function(score)
{
    this.score = score;
}

var s = new Student('David',20,89.0);
console.log(s);
s.Setgender('M');
s.setScore(100);
console.log(s);
```

在写的时候千万不要忘记call函数里面的this指针

### 垃圾回收

在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作，我们需要做的只是要将不再使用的对象设置null即可。

```javascript
function Person(name,age)
{
    this.name = name;
    this.age = age;
}

Person.prototype.Setgender = function(gender)
{
    this.gender = gender;
}

function Student(name,age,score)
{
    Person.call(this,name,age);
    this.score = score;
}

Student.prototype = new Person();
Student.prototype.constructor = Student;
Student.prototype.setScore = function(score)
{
    this.score = score;
}

var s = new Student('David',20,89.0);
console.log(s);
s.Setgender('M');
s.setScore(100);
console.log(s);

s = null;
```

最后对象s被赋上了null后，就可以被自动回收。

# Js常用对象

### 数组对象

使用typeof检查一个数组对象时，会返回object

##### 数组的创建

```javascript
var arr = new Arry();
arr[0] = 1;
arr[1] = 2;
```

但是其实数组的元素也可以是不同类型的元素

```javascript
var arr = new Arry();
arr[0] = 1;
arr[1] = '2';
```

也可以使用Python风格的创建方式

```javascript
var arr = [1,2,'3'];
```

##### 数组的方法

- push方法

  向数组末尾添加元素

  ```javascript
  var arr = [1,2,3];
  var result = arr.push(4,5,6);
  console.log(arr);
  console.log(result);
  ```

  arr.push(...)返回值是添加元素之后的数组长度

- pop方法

  删除数组的最后一个元素

  ```javascript
  var arr = [1,2,3];
  var result = arr.pop();
  console.log(arr);
  console.log(result);
  coonsole.log(typeof result);
  ```

  返回值是被删除的元素

- unshift方法

  向数组开头增加元素，并且返回增加之后的数组长度

- shift方法

  删除数组开头的元素，并且返回被删除的元素

- forEach()方法

  参数为回调函数，不由我们调用。

  forEach()有三个参数，第一个参数就是当前正在遍历的元素；第二个参数就是当前正在遍历的元素的索引；第三个参数就是正在遍历的数组。

  ```javascript
  var arr = [1,2,3];
  arr.forEach(function(value,index,obj){
      console.log(value+'###'+index+'###'+obj);
  });
  ```

  浏览器会自主调用forEach()中定义的回调函数

- slice()方法

  数组的切片

  有两个参数，第一个是起始索引处，第二个是终点索引处，终点不包含。

  返回值是单独被切开来的数组，原来的数组不会受影响。

- splice()方法

  前面有pop()和shift()方法，但是这两种方法无法针对中间位置的元素的删除需求，所以还需要有新的方法

  该方法7有三个参数，第一个参数表示开始位置的索引，第二个参数表示要删除的元素数量，第三个参数及以后参数可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边。

  ```javascript
  var arr = [1,2,3,4,5,6,7,8];
  var returnValue = arr.splice(0,2,'David','Zed');
  console.log(arr);
  console.log(returnValue);
  ```

- concat()方法

  可以连接两个或多个数组，并将新的数组返回，该方法不会对原数组产生影响

- join()方法

  可以将数组转换为一个字符串，该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回，在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符，如果不指定连接符，则默认使用，作为连接符。

- sort方法（需要重点注意的地方）

  默认进行Unicode编码

  ```javascript
  var arr = ["b", "c", "a"];
  arr.sort();
  console.log(arr);
  ```

  所以在字符排序中能够i正常排序，但是遇到数字的时候就会出问题

  所以在对数字进行排序的时候我们需要自己写好回调函数

  sort方法中，回调函数中有两个参数，能够确定的只有第一个参数在数组中的位置在第二个参数的右边

  ```javascript
  var arr = [2,6,1,3,11,7];
  arr.sort(fuction(a,b){
           return a-b;
           }); //a-b>0时会左右调换
  ```

### 函数对象

##### call()方法

调用call()函数时，可以将一个对象指定为第一个参数。

这个第一个对象会成为函数里面的this

```javascript
function fun(a, b) {
    console.log("a = " + a);
    console.log("b = " + b);
    console.log("fun = " + this);
}

var obj = {
    name: "obj",
    sayName: function () {
        console.log(this.name);
    }
};

fun(2, 3);
console.log("===============");
fun.call(obj, 2, 3);
```

默认fun()函数调用，this指向的是window对象，你可以使用call()调用函数，在调用的时候传入一个对象，这个对象就是this所指向的对象，也就是说，可以自己指定this的指向，然后从第二个参数开始，实参将会依次传递.

##### apply()方法

基本和call()方法是一个用法，但是在参数上面call()第二个参数的位置的参数用数组包装起来了

```javascript
function fun(a, b) {
    console.log("a = " + a);
    console.log("b = " + b);
    console.log("fun = " + this);
}

var obj = {
    name: "obj",
    sayName: function () {
        console.log(this.name);
    }
};

fun(2, 3);
console.log("===============");
fun.apply(obj, [2, 3]);
```

##### arguments参数

封装实参的对象

在调用函数时，我们所传递的实参都会在arguments中保存

arguments[0]表示第一个实参，以此类推

arguments有一个属性叫做callee，这个属性对应一个函数对象，就是当前正在指向的函数的对象

```javascript
function fun(a,b)
{
    //打印两个参数
    console.log(arguments[0]);
    console.log(arguments[1]);
    //打印参数的个数
    console.log(arguments.length);
    //打印调用这些参数的函数
    console.log(arguments.callee);
    console.log(arguments.callee==fun);
}

fun("a","b");
```

#### Date对象

```javascript
var date = new Date();
console.log(date);

console.log(date.getFullYear());//获取当前日期对象的年份(四位数字年份)
console.log(date.getMonth());//获取当前日期对象的月份(0 ~ 11)
console.log(date.getDate());//获取当前日期对象的日数(1 ~ 31)
console.log(date.getHours());//获取当前日期对象的小时(0 ~ 23)
console.log(date.getMinutes());//获取当前日期对象的分钟(0 ~ 59)
console.log(date.getSeconds());//获取当前日期对象的秒钟(0 ~ 59)
console.log(date.getMilliseconds());//获取当前日期对象的毫秒(0 ~ 999)
```

### String对象

##### 字符串方法

- charAt()方法：

  ```javascript
  var str = "hello world.";
  console.log(str.charAt(1));
  ```

  能够获取参数值对应索引值的字符

- charCodeAt()方法：

  ```javascript
  var str = "abd";
  console.log(str.charCodeAt(0));
  ```

  能够获取参数值对应索引字符的Unicode编码

- indexOf()方法：

  ```javascript
  var str = "hello hello";
  console.log(str.indexOf("e"));
  ```

  能够返回第一次出现指定字符的位置的索引值

- lastIndexOf()方法:

  ```javascript
  var str = "hello hello";
  console.log(str.lastIndexOf("e"));
  ```

  能够返回最后一次出现指定字符的位置的索引值

- slice()方法：

  ```javascript
  var str = "abcdefghijk";
  console.log(str.slice(1,3));
  ```

  也就是切片，对原字符串不造成影响

- split()方法

  ```javascript
  var str = "hello,world.";
  console.log(str.split(","));
  ```

  分割，以参数里面的字符为界，分割后的结果存在一个数组里面

- toUpperCase(),toLowerCase()方法：

  ```javascript
  var str = "hello,world";
  var STR = str.toUpperCase();
  var str = STR.toLowerCase();
  console.log(str);
  console.log(STR);
  ```

  toUpperCase()将小写的字符全部转化为大写，toLowerCase()方法将所有字符都转为小写。

### RegExp对象

正则对象

##### 语法模式

1. 使用对象的方式创建

```javascript
var Exp = new RegExp("正则表达式","匹配模式");
```

匹配模式：

- i:忽略大小写
- g：全局匹配模式
- ig:忽略大小写并且全局匹配模式

**匹配模式并不是必须的**

```javascript
// 这个正则表达式可以来检查一个字符串中是否含有a
var exp = new RegExp("a","i");
var str = "abcd";
var result = exp.test(str);
console.log(result);
```

输出自然是true

2. 使用字面量创建

```javascript
var exp = /正则表达式/匹配模式;
```

```javascript
var exp = /a/i;
var str = "abcd";
var result = exp.test(str);
console.log(result);
//注意字面量创建的时候不需要加引号
```

##### 正则表达式进阶

- 创建一个正则表达式，检查一个字符串中是否有a或b

  ```javascript
  var exp = /a|b/;
  var str = "Abc";
  var reg = /a/;
  var res1 = exp.test(str);
  var res2 = reg.test(str);
  console.log(res1);
  console.log(res2);
  ```

  这里的|就表达了或者的逻辑意义

- 如果要”或者“的情况很多怎么办，那么就需要用到"[]"了

  ```javascript
  var exp = /[A-z]/;
  var str = "a123";
  var res = exp.test(str);
  console.log(res);
  ```

  这里的意义就是是否存在字母，其他常用的组合还有

  - [a-z]：任意小写字母
  - [A-Z]：任意大写字母
  - [A-z]：任意字母
  - [0-9]：任意数字

  【】还可以用在字符串中间用来筛查，比如检查一个字符串中是否含有 abc 或 adc 或 aec。

  ```javascript
  var reg = /a[bde]c/;
  var str = "abc";
  var res = reg.test(str);
  console.log(res);
  ```

- 【^】表达式还可以用来表达”除了“的逻辑关系

  - [^a-z]：除了任意小写字母
  - [^A-Z]：除了任意大写字母
  - [^A-z]：除了任意字母
  - [^0-9]：除了任意数字

  ```javascript
  var reg = /[^0-9]/;
  var str = "abcd";
  var res = reg.test(str);
  console.log(res);
  ```

##### 正则方法

其实是字符串的方法，但是参数为正则表达式

- split方法的参数

  ```javascript
  var str = "1a2c3d4";
  var res = str.split(/[a-Z]/);
  console.log(res);
  ```

  这样就可以用字母为分隔，得到里面的其他成分了

- search()方法

  搜索字符串中是否含有指定内容，如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1

  ```javascript
  var str = "hello abc hello aec afc";
  var result = str.search(/a[bef]c/);
  console.log(result);
  ```

- match()方法

  从一个字符串中将符合条件的内容提取出来，默认情况下我们的match()只会找到第一个符合要求的内容，找到以后就停止检索

  但是如果要全部找的话就调一下匹配模式就可以了

  ```javascript
  var str = "1a2a3a4a5e6f7A8B9C";
  var result = str.match(/[a-z]/ig);
  console.log(result);
  ```

  就是不分大小写从整个字符串中查找对应内容并放入数组中

- replace()方法

  默认只会替换第一个，但是可以设置全局匹配替换全部

  ```javascript
  var str = "1a2a3a4a5e6f7A8B9C";
  var res = str.replace(/[A-z]/,"@_@");
  console.log(res);
  ```

##### 正则量词

在正则对象的描述中设置出现的次数

- `{n}` ：正好出现n次
- `{m,}` ：出现m次及以上
- `{m,n}` ：出现m-n次

```javascript
var str = "abbc";

var reg1 = /[A-z]{3,}/;
var res1 = reg1.test(str);
var reg2 = /a{1}/;
var res2 = reg2.test(str);

console.log(res1);
console.log(res2);
```

条件在写的时候还可以插入在中间，表示对条件前的表达式进行条件设置

- `+` ：至少一个，相当于{1,}
- `*` ：0个或多个，相当于{0,}
- `?` ：0个或1个，相当于{0,1}

```javascript
var str = "abbc";

var reg1 = /[A-z]+c?/;
var res1 = reg1.test(str);
var reg2 = /a*c?/;
var res2 = reg2.test(str);

console.log(res1);
console.log(res2);
```

##### 正则高阶

- 要检查或者说判断是否以某个字符或者字符序列开头或者结尾就会使用^和$

  ```javascript
  var str = "abba";
  var reg1 = /^a/;
  var reg2 = /a$/;
  
  var res1 = reg1.test(str);
  var res2 = reg2.test(str);
  
  console.log(res1);
  console.log(res2);
  ```

- 转义字符

  " \ ."和”\ \“是'.'和'\ '的转义字符

  - `\w` ：任意字母、数字、_，相当于[A-z0-9_]
  - `\W` ：除了字母、数字、_，相当于[^A-z0-9_]
  - `\d` ：任意的数字，相当于`[0-9]`
  - `\D` ：除了任意的数字，相当于`[^0-9]`
  - `\s` ：空格
  - `\S` ：除了空格
  - `\b` ：单词边界
  - `\B` ：除了单词边界

# Dom

### 概述

DOM 是关于如何获取、更改、添加或删除 HTML 元素的标准。

DOM节点是指网页中的每一个部分，包括整个文档

### DOM文档操作

document对象作为window对象的属性存在的，我们不用获取可以直接使用。

- document.getElementById(*id*)：通过元素 id 来查找元素。
- document.getElementsByTagName(*name*)： 通过标签名来查找元素。
- document.getElementsByClassName(*name*)： 通过类名来查找元素。
- document.querySelector(*CSS选择器*)： 通过CSS选择器选择一个元素。
- document.querySelectorAll(*CSS选择器*)： 通过CSS选择器选择多个元素。

#### 获取文档信息

首先要找到对应的元素

```javascript
//根据ID查找
var res1 = document.getElementById("btn");
console.log(res1);
//根据标签名查找
var res2 = document.getElementsByTagName("button");
console.log(res2);
//根据类名查找
var res3 = document.getElementsByClassName("btn");
console.log(res3);
//用选择器查找
var res1 = document.querySelector(".btn");
console.log(res1);
//创建一个列表用于存储所有符合的元素
var res2 = document.querySelectorAll("ul li");
console.log(res2);
```

对应的html文件

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./Day2.css">
</head>
<body id="body">
    <button id="btn">我是按钮</button>
    <button class="btn">我也是按钮</button>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
    </ul>
    <a href="https://www.baidu.com" id="a">链接</a>
    <div id="vital" 
    style="background-color: rgb(255, 0, 0);
    height: 100px;
    width: 100px;">
    </div>
    <script src="./Day2.js"></script>
</body>
</html>
```

在查找的过程中发现能够用来索引具体值的取法是有限的，只有ID查找和选择器查找可以

然后可以去索引对应的值

- 元素节点.innerText:获取 HTML 元素的 inner Text。
- 元素节点.innerHTML:获取 HTML 元素的 inner HTML。
- 元素节点.属性:获取 HTML 元素的属性值。
- 元素节点.getAttribute(*attribute*):获取 HTML 元素的属性值。
- 元素节点.style.样式:获取 HTML 元素的行内样式值。
- getComputedStyle(元素节点,null).属性:获取 HTML 元素的行内样式值。

```javascript
var res1 = document.getElementById("btn");
var result = res1.innerText;
console.log(result);
var result = res1.innerHTML;
console.log(result);

var res2 = document.getElementById("body");
var result = res2.innerHTML;
console.log(result);

var res3 = document.getElementById("a");
console.log(res3.href);

var res1 = document.getElementById("vital");
//仅用于内联式的
console.log(res1.style.width);
//这种则用于另外两种形式
console.log(getComputedStyle(res1,null).width);
```

#### 改变HTML的值

就是对获取的值进行新的赋值运算

#### 修改HTML元素

- document.createElement(*element*)：创建 HTML 元素节点。
- document.createAttribute(*attribute*)：创建 HTML 属性节点。
- document.createTextNode(*text*)： 创建 HTML 文本节点。
- 元素节点.removeChild(*element*)： 删除 HTML 元素。
- 元素节点.appendChild(*element*)： 添加 HTML 元素。
- 元素节点.replaceChild(*element*)： 替换 HTML 元素。
- 元素节点.insertBefore(*element*，element)： 在指定的子节点前面插入新的子节点。

```javascript
var ul = document.createElement("ul");

var li1 = document.createElement("li");
var text1 = document.createTextNode("列表1");
li1.appendChild(text1);

var li2 = document.createElement("li");
var text2 = document.createTextNode("列表2");
li2.appendChild(text2);

ul.appendChild(li1);
ul.appendChild(li2);

var uL = document.getElementById("a");
var b = document.getElementById("body");
b.insertBefore(ul,uL);
```

这里我们在a标签前插入了一个列表，格外要注意insertBefore()的用法

父元素.insertBefore(要插入的子元素,原来就在的子元素)

#### 查找HTML父子

![](https://s3.bmp.ovh/imgs/2022/07/10/3214f880481e7061.png)

### DOM事件

#### 窗口事件

- onblur:当窗口失去焦点时运行脚本。
- onfocus:当窗口获得焦点时运行脚本。
- onload:当文档加载之后运行脚本。
- onresize:当调整窗口大小时运行脚本。
- onstorage: 当 Web Storage 区域更新时（存储空间中的数据发生变化时）运行脚本。

```javascript
window.onload = function () {
    alert("hello world!");
}

window.onresize = function () {
    alert("窗口大小正在改变。");
}
```

窗口对象即window，对应的事件被赋值

#### 表单事件

表单事件在HTML表单中触发 (适用于所有 HTML 元素，但该HTML元素需在form表单内)

- onblur:当元素失去焦点时运行脚本。
- onfocus:当元素获得焦点时运行脚本。
- onchage:当元素改变时运行脚本。改变之后也需要失焦才能够触发事件
- oninput:当元素获得用户输入时运行脚本。
- onselect: 当选取元素时运行脚本。
- onsubmit: 当提交表单时运行脚本。

```javascript
//当文本框获取焦点，文本框背景为红色，当文本框失去焦点，文本框背景为白色
var text = document.getElementById("text");
text.onfocus = function ()
{
    text.style.backgroundColor = "red";
}

text.onblur = function ()
{
    this.style.backgroundColor = "white";
}
//文本框内容改变时，鼠标离开文本框（所谓的离开文本框也就是文本框失焦），自动将文本框的内容输出到控制台
text.onchange = function ()
{
    console.log(this.value);
}
//当文本框内容改变时，立即将改变的内容输出到控制台
text.oninput = function ()
{
    console.log(this.value)
}
//
var sub = document.getElementById("submit");

sub.onclick = function ()
{
    if( text.value == "")
    {
        alert("喂，什么都不写总不太好的");
    }
    else 
    {
        console.log(text.value);
        alert("表单已提交");
    }
}
```

编码过程中：

1. 用DOM document对象选中要操作的对象
2. 对象.事件 = function(){}

#### 键盘事件

通过键盘触发事件，类似用户的行为

- onkeydown:当按下按键时运行脚本。
- onkeyup:当松开按键时运行脚本。
- onkeypress:当按下并松开按键时运行脚本。

```javascript
var box = document.getElementById("vital");
window.onkeydown = function (event)
{
    var speed = 100;
    var event = event;
    if (event.keyCode == 37)
    {
        box.style.left = box.offsetLeft - speed +"px";
    }
    if (event.keyCode == 39)
    {
        box.style.left = box.offsetLeft + speed +"px";
    }
    if (event.keyCode == 38)
    {
        box.style.top = box.offsetTop - speed +"px";
    }
    if (event.keyCode == 40)
    {
        box.style.top = box.offsetTop + speed +"px";
    }
}
```

这个就可以操控box对象在方向键的控制下移动

从

```javascript
box.style.left = box.offsetLeft - speed +"px";
```

中可以看出其实这些属性值也都是以字符串的形式在保存的

其中键盘事件中还有键鼠属性要控制

| 属性     | 描述                                       |
| -------- | ------------------------------------------ |
| crtlKey  | 返回当事件被触发时，“CTRL” 键是否被按下。  |
| altKey   | 返回当事件被触发时，“ALT” 是否被按下。     |
| shiftKey | 返回当事件被触发时，“SHIFT” 键是否被按下。 |
| clientX  | 返回当事件被触发时，鼠标指针的水平坐标。   |
| clientY  | 返回当事件被触发时，鼠标指针的垂直坐标。   |
| screenX  | 返回当事件被触发时，鼠标指针的水平坐标。   |
| screenY  | 返回当事件被触发时，鼠标指针的垂直坐标。   |

```javascript
if (event.keyCode == 37)
    {
        if(event.ctrlKey)
        {
            alert("松开‘ctrl’");
        }
        box.style.left = box.offsetLeft - speed +"px";
    }
```

这时如果按着ctrl键的话就要跳出警报

#### 鼠标事件

| 属性         | 描述                                               |
| ------------ | -------------------------------------------------- |
| onclick      | 当单击鼠标时运行脚本。                             |
| ondblclick   | 当双击鼠标时运行脚本。                             |
| onmousedown  | 当按下鼠标按钮时运行脚本。                         |
| onmouseup    | 当松开鼠标按钮时运行脚本。                         |
| onmousemove  | 当鼠标指针移动时运行脚本。                         |
| onmouseover  | 当鼠标指针移至元素之上时运行脚本，不可以阻止冒泡。 |
| onmouseout   | 当鼠标指针移出元素时运行脚本，不可以阻止冒泡。     |
| onmouseenter | 当鼠标指针移至元素之上时运行脚本，可以阻止冒泡。   |
| onmouseleave | 当鼠标指针移出元素时运行脚本，可以阻止冒泡。       |
| onmousewheel | 当转动鼠标滚轮时运行脚本。                         |
| onscroll     | 当滚动元素的滚动条时运行脚本。                     |

```javascript
var box = document.getElementById("vital");
box.onmouseenter = function()
{
    box.style.backgroundColor = "green";
}

box.onmouseleave = function ()
{
    box.style.backgroundColor = "red";
}

box.onmousedown = function(event)
{
    var event = event;

    var ol = event.clientX - box.offsetLeft;
    var ot = event.clientY - box.offsetTop;

    box.onmousemove = function (event)
    {
        var event = event;
        var left = event.clientX - ol;
        var top = event.clientY - ot;

        box.style.left = left + "px";
        box.style.top = top + "px";
    };
    box.onmouseup = function()
    {
        box.onmousemove = null;
    }//防止松开之后还能拖动
}
```

这里就是设计的一个能够拖动小方块的js脚本

#### 事件冒泡

指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发，在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡。

```javascript
var div1 = document.getElementById("div1");
div1.onclick = function()
{
    console.log("this is div1.");
}

var div2 = document.getElementById("div2");
div2.onclick = function()
{
    console.log("this is div2.");
}
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./Day3.css">
</head>
<body>
    <div id="div1">
        这是DIV1
        <div id="div2">
            这是DIV2
        </div>
    </div>
    <script src="./Day3.js"></script>
</body>
</html>
```

```css
#div1
{
    width: 100px;
    height: 100px;
    background-color:azure;
}

#div2{
    width: 50px;
    height: 50px;
    background-color:aquamarine;
}
```

在这里我们的输出结果是

![](https://s3.bmp.ovh/imgs/2022/07/12/77ef4e7b2445ac18.png)

可以看出出现了冒泡事件

若要终止冒泡事件，就要在每次的事件处理方案后加入终止冒泡的操作

```javascript
var div1 = document.getElementById("div1");
div1.onclick = function()
{
    console.log("this is div1.");
    stopBubble();
}

var div2 = document.getElementById("div2");
div2.onclick = function()
{
    console.log("this is div2.");
    stopBubble();
}

var stopBubble = function(event)
{
    // 如果提供了事件对象，则这是一个非IE浏览器
    if (event && event.stopPropagation)
    {
        // 因此它支持W3C的stopPropagation()方法
        event.stopPropagation();
    }
    else
    {
        // 否则，我们需要使用IE的方式来取消事件冒泡
        window.event.cancelBubble = true;
    }
}
```

#### 事件委派

简单理解，就是对一类对象进行事件的绑定

通常是用选择器来选定对象的数组

```javascript
var al = document.querySelectorAll(".al");

for (var i =0;i<al.length;i++)
{
    al[i].onclick = function ()
    {
        stopDefault();
    }
}


var ul = document.getElementById("ul");
ul.onclick = function(event)
{
    event = event;
    if (event.target.className == "al")
    {
        console.log("点到链接辣");
    }
    else
    {}
}
```

```html
    <ul id="ul">
        <li>
            <a href="https://www.baidu.com" class="al">链接一</a>
        </li>
        <li>
            <a href="https://www.baidu.com" class="al">链接二</a>
        </li>
        <li>
            <a href="https://www.baidu.com" class="al">链接三</a>
        </li>
    </ul>
```

这里就实现了一个点击链接后在控制台输出”点到链接辣“文字的需求

#### 事件绑定

有的时候我们需要为同一个对象绑定多个事件函数，而且也会需要能够解绑

下面是案例

```javascript
    function f1() {
        console.log("output1 ...");
    };

    function f2() {
        console.log("output2 ...");
    };

    // 为按钮1的单击事件绑定两个函数
    addEventListener(document.getElementById("btn1"), "click", f1);
    addEventListener(document.getElementById("btn1"), "click", f2);

    // 点击按钮2取消按钮1的单机事件绑定函数f1
    document.getElementById("btn2").onclick = function () {
        removeEventListener(document.getElementById("btn1"), "click", f1);
    };

    /*为元素绑定事件兼容性代码*/
    function addEventListener(element, type, fn) {
        if (element.addEventListener) {
            element.addEventListener(type, fn, false);
        } else if (element.attachEvent) {
            element.attachEvent("on" + type, fn);
        } else {
            element["on" + type] = fn;
        }
    }

    /*为元素解绑事件兼容性代码*/
    function removeEventListener(element, type, fnName) {
        if (element.removeEventListener) {
            element.removeEventListener(type, fnName, false);
        } else if (element.detachEvent) {
            element.detachEvent("on" + type, fnName);
        } else {
            element["on" + type] = null;
        }
    }

```

这里由于浏览器版本问题，所以需要进行多种情况的选择

#### 事件传播

事件传播分为三个阶段：

1. 捕获阶段：在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件
2. 目标阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件
3. 冒泡阶段：事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件

# Bom

### 概述

使 JavaScript 有能力与浏览器"对话"。

浏览器对象模型（BOM）可以使我们通过JS来操作浏览器，在BOM中为我们提供了一组对象，用来完成对浏览器的操作，常见的BOM对象如下：

- Window：代表的是整个浏览器的窗口，同时window也是网页中的全局对象
- Navigator：代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
- Location：代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面
- History：代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录，由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效
- Screen：代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息

### Window对象

#### 弹出框

1. 警告框

   ```javascript
   alert("这是警告框");
   window.alert("这是警告框");
   //window对象的方法不用加window前缀
   ```

2. 确认框

   ```javascript
   window.confirm("sometext");
   ```

   这里用户必须选择确定或者取消，确定返回值为true,取消返回值为false

   ```javascript
   if(confirm("真的要进入这个网站吗？"))
   {
       console.log("欢迎欢迎");
   }
   else
   {
       console.log("拜拜了您内！");
   }
   ```

3. 提示框

   希望用户在进入页面前输入值，通常会使用提示框。

   提示框弹出时，用户将不得不输入值后单击“确定”或点击“取消”来继续进行。

   如果用户单击“确定”，该框返回输入值。如果用户单击“取消”，该框返回 null。

   但是可以有两个参数，第二个参数即为输入值的默认值

   ```javascript
   var person = prompt("请输入你的名字","爱吃炸鱼的薯条");
   if(person != null)
       {
           console.log(person);
       }
   ```

#### 定时事件

#### 延时器

```javascript
window.setTimeout(function, milliseconds);
//window可去
```

这里展示一个点击三秒后输出一个hello world的案例

```javascript
var btn = document.getElementById("btn");

btn.onclick = function()
{
    var timer = setTimeout(function()
    {
        console.log("hello world");
    },3000);
}
```

#### 定时器

```javascript
window.setInterval(function, milliseconds);
//window可去
```

也就是每个milliseconds时间执行函数function

```javascript
var btn = document.getElementById("btn");

btn.onclick = function()
{
    var timer = setInterval(function(){
        console.log("hello world");
    },1000);
}
```

这里就是点击按钮之后每隔一秒钟输出一个"hello world"。

#### 常用窗口属性

一个实用的 JavaScript 解决方案（包括所有浏览器）：该例显示浏览器窗口的高度和宽度（不包括工具栏和滚动条）：

```javascript
    var w = window.innerWidth
        || document.documentElement.clientWidth
        || document.body.clientWidth;

    var h = window.innerHeight
        || document.documentElement.clientHeight
        || document.body.clientHeight;
```

#### 其他窗口方法

- window.open()

  ```javascript
  window.open(URL,name,specs,replace);
  ```

  ![](D:\zhuomian\2022年暑假小项目\javascript\images\786bc5b7eacc1a8aba149c0741484aee.png)

  

  ![](https://s3.bmp.ovh/imgs/2022/07/14/a80ccc454f4d70ec.png)

- window.close()

  关闭当前窗口

- window.moveTo(x,y)

  移动至当前窗口

  也就是打开一个新的窗口，新窗口的链接为window的地址

  ```javascript
  var myWindow = open('https://www.baidu.com','','');
  myWindow.moveTo(100,100);
  myWindow.focus();
  ```

- window.resizeTo()

  调整当前窗口大小

  ```javascript
  window.resizeTo(width,height);
  ```

### Navigator对象

Navigator代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器，由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了，一般我们只会使用userAgent来判断浏览器的信息，userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent
```javascript
var ua = navigator.userAgent;
if (/firefox/i.test(ua)) {
    alert("你是火狐浏览器");
} else if (/chrome/i.test(ua)) {
    alert("你是谷歌浏览器");
} else if (/msie/i.test(ua)) {
    alert("你是IE5-IE10浏览器");
} else if ("ActiveXObject" in window) {
    alert("你是IE11浏览器");
}
```

